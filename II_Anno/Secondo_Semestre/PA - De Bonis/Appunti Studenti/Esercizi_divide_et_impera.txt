Scrivere un algoritmo che trova il min e il max di un array di numeri con meno di 2n-2 confronti
Iterativo:
Min-Max(a)
{
	min = max = a[0];
	for(i = 1; i < n; i++)
	{
		if(a[i] < min)
			min = a[i];
		if(a[i] > max)
			max = a[i];
	}
	return <min, max>;
}

Divide-et-Impera:
Min-Max(a, sx, dx)
{
	if(sx == dx)
		return <a[sx], a[dx]>;
	if(sx == dx - 1)
		if(a[sx] < a[dx])
			return <a[sx], a[dx]>;
		else
			return <a[dx], a[sx]>;
	cx = (sx + dx) / 2;
	<min1, max1> = MinMax(a, sx, cx);
	<min2, max2> = MinMax(a, cx + 1, dx);
	
	return (min(min1, min2), max(max1, max2));
}

Dimostrazione che impieghiamo meno di 2n - 2 confronti

	{ 0					se n = 1
T(n) =	{ 1					se n = 2
	{ T(p.b.(n/2)) + T(p.a.(n/2)) + 2	se n > 2

Assumiamo n = 2^k con k > 1

Iterando la ricorrenza: T(n) = 3/2n - 2

-----------------------------------------------------------------------------------------------------------------------------
Scrivere un algoritmo ricorsivo basato sul divide et impera che conta il numero di elementi positivi in un array a di n numeri
Pos(a, sx, dx)
{
	if(sx > dx)
		return 0;
	if(sx == dx)
		if(a[sx] > 0)
			return 1;
		else
			return 0;
	cx = (sx + dx) / 2;
	return Pos(a, sx, cx) + Pos(a, cx + 1, dx);
}

-----------------------------------------------------------------------------------------------------------------------
Scrivere un algoritmo basato sul Divide et Impera che, dato un array a ordinato, restituisce true se e solo se a contiene duplicati
CheckDuplicate(a, sx, dx)
{
	if(sx >= dx)
		return false;
	cx = (sx + dx) / 2;
	if(a[cx] == a[cx + 1])
		return true;
	return (CheckDuplicate(a, sx, cx) || CheckDuplicate(a, cx + 1, dx));
}
-----------------------------------------------------------------------------------------------------------------------------
Scrivere un algoritmo che, dato un array a di numeri ordinati in ordine non decrescente ed un numero m, restituisce l'indice dell'elemento dell'array più piccolo tra quelli strettamente maggiori di m. Se a non contiene alcun elemento maggiore di m allora l'algoritmo restituisce -1.
LimiteSup(a, sx, dx, k)
{
	if(sx > dx)
		return -1;
	if(sx == dx && a[i] > m)
		return i;
	cx = (sx + dx) / 2;
	if(k >= a[c])
		return LimiteSup(a, cx + 1, dx, k);
	else
		return LimiteSup(a, sx, cx, k);
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Scrivere un algoritmo che prende in input un nodo u di un albero binario e un elemento x e conta il numero di foglie dell'albero radicato in u che contengono x
Conta(u, x)
{
	if(u == NULL)
		return 0;
	if(u.sx == NULL && u.dx == NULL)
	{
		if(u.dato == x)
			return 1;
		else
			return 0;
	}
	

	return Conta(u.sx, x) + Conta(u.dx, x);
}
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Scrivere un algoritmo che prende in input un nodo u di un albero binario ed effettua una visita inorder dell'albero radicato in u restituendo true non appena trova un nodo che ha esattamente un figlio
Trova(u)
{
	if(u == NULL)	//Caso base
		return false;
	if(u.sx != NULL && u.dx!= NULL) //Ha due figli
		return trova(u.sx) || trova(u.dx);
	return true;
}
--------------------------------------------------------------------------------------------------------------------------------------------------
Scrivere un algoritmo che prende in input un nodo u di un albero binario ed un elemento x ed effettua una visita inorder dell'albero radicato in u restituendo true non appena trova un nodo che contiene x
CercaInorder(u, x)
{
	if(u == NULL)
		return false;
	if(u.dato == x)
		return true;
	return CercaInorder(u.sx) || CercaInorder(u.dx);
}
------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Scrivere un algoritmo che prende in input un nodo u di un albero binario ed un elemento x ed effettua una visita postorder dell'albero radicato in u restituendo true non appena trova un nodo che contiene x
CercaPostorder(u, x) //Spero sia così
{
	if(u == NULL)
		return false;
	left = CercaPostorder(u.sx, x);
	right = CercaPostorder(u.dx, x);
	
	if(u.dato == x)
		return true;
	
	return left || right;
}
----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Scrivere un algoritmo che prende in input due alberi binari e restituisce true solo se hanno la stessa struttura
Check(t1, t2)
{
	if(t1.dimensione == 0 && t2.dimensione == 0)
		return true;
	if(t1.dimensione == 0 || t2.dimensione == 0)
		return false;
	return check_aux(t1.radice, t2.radice);
}
check_aux(u, v)
{
	if(u == NULL && v == NULL)
		return true;
	if(u == NULL || v == NULL)
		return false;
	return ckeck(u.sx, v.sx) && check(u.dx, v.dx);
}
--------------------------------------------------------------------------------------------------------------------------------